InstructionSet XCoreVMac extends RISCVBase {
    instructions {
        // 32-Bit x 32-Bit Multiplication Operations (Signed)
        CV_MAC {
            encoding: 7'b1001000 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
              signed<65> result = (signed)X[rs1] * (signed)X[rs2] + (signed)X[rd];
              // signed<64> result = (signed)X[rs1] * (signed)X[rs2] + (signed)X[rd];
              // if(rd != 0) X[rd] = result[31:0];
              if(rd != 0) X[rd] = (unsigned<32>)result;
            }
        }
        // CV_MSU {
        //     encoding: 7'b1001001 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
        //     behavior: {
        //       // signed<65> result = (signed)X[rd] - (signed)X[rs1] * (signed)X[rs2] ;
        //       signed<64> result = (signed)X[rd] - (signed)X[rs1] * (signed)X[rs2] ;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // disabled since these would use v2i16 vectors
        // // 16-Bit x 16-Bit Multiplication
        // CV_MULUN {
        //     encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       unsigned<32> result = ((unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned)result;
        //     }
        // }
        // CV_MULHHUN {
        //     encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       unsigned<32> result = ((unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MULSN {
        //     encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       signed<32> result = ((signed)X[rs1][15:0] * (signed)X[rs2][15:0]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MULHHSN {
        //     encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       signed<32> result = ((signed)X[rs1][31:16] * (signed)X[rs2][31:16]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MULURN {
        //     encoding: 2'b10:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// unsigned<32> sum = product + powerOf2;
				// unsigned<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MULHHURN {
        //     encoding: 2'b11:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// unsigned<32> sum = product + powerOf2;
				// unsigned<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MULSRN {
        //     encoding: 2'b10:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (signed)X[rs1][15:0] * (signed)X[rs2][15:0];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// signed<32> sum = product + powerOf2;
				// signed<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MULHHSRN {
        //     encoding: 2'b11:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (signed)X[rs1][31:16] * (signed)X[rs2][31:16];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// signed<32> sum = product + powerOf2;
				// signed<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // // 16-Bit x 16-Bit Multiply-Accumulate
        // CV_MACUN {
        //     encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       unsigned<32> result = ((unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0] + (unsigned)X[rd]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MACHHUN {
        //     encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       unsigned<32> result = ((unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16] + (unsigned)X[rd]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MACSN {
        //     encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       signed<32> result = ((signed)X[rs1][15:0] * (signed)X[rs2][15:0] + (signed)X[rd]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MACHHSN {
        //     encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
        //       signed<32> result = ((signed)X[rs1][31:16] * (signed)X[rs2][31:16] + (signed)X[rd]) >> Is3;
        //       if(rd != 0) X[rd] = (unsigned<32>)result;
        //     }
        // }
        // CV_MACURN {
        //     encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (unsigned)(X[rs1][15:0]) * (unsigned)(X[rs2][15:0]);
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// unsigned<33> sum = product + (unsigned)X[rd] + powerOf2;
				// unsigned<33> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MACHHURN {
        //     encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// unsigned<32> product = (unsigned)(X[rs1][31:16]) * (unsigned)(X[rs2][31:16]);
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// unsigned<33> sum = product + (unsigned)X[rd] + powerOf2;
				// unsigned<33> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MACSRN {
        //     encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// signed<32> product = (signed)X[rs1][15:0] * (signed)X[rs2][15:0];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// signed<32> sum = product + (signed)X[rd] + powerOf2;
				// signed<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
        // CV_MACHHSRN {
        //     encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1011011;
        //     assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
        //     behavior: {
				// signed<32> product = (signed)X[rs1][31:16] * (signed)X[rs2][31:16];
				// unsigned<32> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				// signed<32> sum = product + (signed)X[rd] + powerOf2;
				// signed<32> rounded = sum >> Is3;

				// X[rd] = (unsigned<32>)rounded;
        //     }
        // }
    }
}
